#!/usr/bin/env ruby

# == Synopsis
#
# una: Universal un-archiver interface for Mac OS X
#
# Version 1.1, by John Wiegley <johnw@newartisans.com>
#
# This is a "universal" unarchiver for the OS X, written because I'm too lazy
# to remember all the testing/listing/extracting options for the large number
# of archive formats I come into contact with.
#
# Dependencies:
#   StuffIt Expander (free, expander-only version)
#   MacPorts: unarj, unrar, lha, lzma, p7zip, cabextract
#
# == Usage
#
# una [OPTION] ARCHIVE...
#
# If no OPTION is specified, the default action is to extract the archive's
# contents into the current directory.
#
# Options:
#   -h, --help    show help
#   -t, --test    test the archive
#   -l, --list    list the archive's contents (except StuffIt)
#
# This script is also smart about unarchiving:
#
#   a) if all the contents of an archive would already extract into a single
#      directory, do that;
#
#   b) if the archive contains only one item, extract it into the current
#      directory;
#
#   c) otherwise, if the archive would dump multiple contents into the current
#      directory, create a new directory based on the name of the archive,
#      sans extension, and put everything there.

# dmg, iso, cpio*, lzma, rar, cab
# todo: arc, deb, jar, uu, rpm, rzip, alz, zoo, xar
#
# jww (2008-10-05): Rewrite using classes, instead of lame handlers
#
#  .7z         # p7zip
#  .Z          # UNIX compress
#  .ARJ        # Arj
#  .BIN        # MacBinary
#  .BXY        # some old Binary II format
#  .BNY        # some old Binary II format
#  .BQY        # some old Binary II format
#  .bz2        # Bzip2
#  .CAB        # Windows CABinet files
#  .cpgz       # gzip'd CPIO
#  .cpio       # CPIO
#  .cpio.Z     # compress'd CPIO
#  .cpio.bz2   # bzip2'd CPIO
#  .dmg        # Apple Disk Image
#  .gz         # Gzip
#  .HQX        # BinHex?
#  .ISO        # CD-ROM ISO9660
#  .LHA        # LHarc
#  .LZH        # LHarc again
#  .RAR        # WinRAR
#  .SDK        # ShrinkIt disk
#  .SEA        # StuffIt Expander archive
#  .SHK        # ShrinkIt archive
#  .SIT        # StuffIt archive
#  .tar        # TAR
#  .tar.7z     # p7zip'd TAR
#  .tar.Z      # compress'd TAR
#  .tar.bz2    # bzip2'd TAR
#  .tar.gz     # gzip'd TAR
#  .taz        # compress'd TAR
#  .tbz        # bzip2'd TAR
#  .tgz        # gzip'd TAR
#  .ZIP        # zip'd TAR
#
#
# Use the -T flag if you want the archive to be extracted at its source (i.e.,
# next to it), rather than in the current directory.
#
# Use the --delete flag if you want the original archive destroyed upon
# successful extraction.

require 'ftools'
require 'getoptlong'
require 'rdoc/usage'

$extract_there = false
$preserve      = true
$verbose       = false
$command       = :extract

opts = GetoptLong.new(
  [ "--help",     "-h", GetoptLong::NO_ARGUMENT ],
  [ "--identify", "-i", GetoptLong::NO_ARGUMENT ],
  [ "--test",     "-t", GetoptLong::NO_ARGUMENT ],
  [ "--there",    "-T", GetoptLong::NO_ARGUMENT ],
  [ "--delete",   "-D", GetoptLong::NO_ARGUMENT ],
  [ "--verbose",  "-v", GetoptLong::NO_ARGUMENT ],
  [ "--list",     "-l", GetoptLong::NO_ARGUMENT ]
)

$handlers = []

class Archive
  def advertise
    puts "  .???   Unknown"
  end

  def match?(path)
    return nil
  end

  def sepchar
    return "/"
  end

  def identify(path)
    puts "Unknown format."
  end

  def test(path)
    return true
  end

  def list(path)
    return []
  end

  def extract(path)
    puts "Error: Failed to extract #{path}: Format unknown"
  end
end

class Filter
  def advertise
    puts "  .???   Unknown"
  end

  def match?(path)
    return nil
  end

  def identify(path)
    puts "Unknown format."
  end

  def test(path)
    return true
  end

  def decompress(path)
    puts "Error: Failed to decompress #{path}: Format unknown"
  end
end

class DiskImage < Archive
  def advertise
    puts "  .DMG   Apple Disk Image"
    puts "  .ISO   CD-ROM ISO9600"
  end

  def match?(path)
    if path =~ /\.(dmg|iso)$/i
      return file.gsub(/\.(dmg|iso)$/, "")
    end
  end

  def test(path)
    `hdiutil verify -quiet "#{path}"`
    $? == 0
  end

  def list(path)
    lines = []
    tmppath = _mount(path)
    if tmppath
      begin
        Dir.chdir(tmppath) do
          `find .`.split("\n").each do |line|
            lines.push line[2..-1]
          end
        end
      ensure
        _umount(path)
      end
    end
    lines
  end

  def extract(path)
    result  = false
    tmppath = _mount(path)
    if tmppath
      begin
        `ditto #{tmppath} .`      # jww (2008-10-05): not exactly what I mean yet...
        result = $? == 0
      ensure
        _umount(path)               # jww (2008-10-05): even if an error occurs
      end
    end
    result
  end

private
  def _mount(path)
    tmppath = nil
    flags = "-readonly -mountrandom /tmp -noverify -noautofsck"
    `hdiutil attach "#{path}" #{flags}`.split("\n").each do |line|
      if line =~ /(\/tmp\/dmg.+)/
        tmppath = $1
      end
    end
    tmppath
  end

  def _unmount(path)
    if File.exists? path
      `hdiutil detach #{path} -force`
    end
  end
end

$handlers.push DiskImage.new

def diskimage_handler(cmd, path)
  case cmd
  when :test
    `hdiutil verify -quiet "#{path}"`
    $? == 0

  when :list
    path  = nil
    flags = "-readonly -mountrandom /tmp -noverify -noautofsck"
    `hdiutil attach "#{path}" #{flags}`.split("\n").each do |line|
      if line =~ /(\/tmp\/dmg.+)/
        path = $1
      end
    end

    if path
      lines = []
      Dir.chdir(path) do
        `find .`.split("\n").each do |line|
          lines.push line[2..-1]
        end
      end
      lines
    end
    `hdiutil detach #{path} -force`
    lines

  when :extract
    result = false
    path   = nil
    flags  = "-readonly -mountrandom /tmp -noverify -noautofsck"
    `hdiutil attach "#{path}" #{flags}`.split("\n").each do |line|
      if line =~ /(\/tmp\/dmg.+)/
        path = $1
      end
    end

    if path
      `ditto #{path} .`
      lines = []
      Dir.chdir(path) do
        `find .`.split("\n").each do |line|
          lines.push line[2..-1]
        end
      end
      lines
    end
    `hdiutil detach #{path} -force`
    lines
    result = $? == 0
  end
end

def shrinkit_handler(cmd, path)
  case cmd
  when :test
    `nulib2 -i "#{path}"`
    $? == 0

  when :list
    `nulib2 -t "#{path}"`.split("\n")

  when :extract
    `nulib2 -x "#{path}"`
    $? == 0
  end
end

def unzip_handler(cmd, path)
  case cmd
  when :test
    `unzip -tq "#{path}"`
    $? == 0

  when :list
    lines = []
    `unzip -l "#{path}"`.split("\n")[3..-3].each do |line|
      lines.push line[28..-1]
    end
    lines

  when :extract
    `unzip -q "#{path}"`
    $? == 0
  end
end

def unarj_handler(cmd, path)
  case cmd
  when :test
    `unarj t "#{path}" > /dev/null 2>&1`
    $? == 0

  when :list
    lines = []
    `unarj l "#{path}"`.split("\n")[6..-3].each do |line|
      lines.push line[0..12]
    end
    lines

  when :extract
    `unarj x "#{path}" > /dev/null`
    $? == 0
  end
end

def unrar_handler(cmd, path)
  case cmd
  when :test
    `unrar t "#{path}" > /dev/null 2>&1`
    $? == 0

  when :list
    lines = []
    `unrar vb "#{path}"`.split("\n").each do |line|
      lines.push line
    end
    lines

  when :extract
    `unrar x "#{path}" > /dev/null`
    $? == 0
  end
end

def lha_handler(cmd, path)
  case cmd
  when :test
    true                        # can't test this format

  when :list
    lines = []
    `lha l "#{path}"`.split("\n")[2..-3].each do |line|
      lines.push line[51..-1]
    end
    lines

  when :extract
    `lha x "#{path}" > /dev/null`
    $? == 0
  end
end

def gzip_handler(cmd, path)
  case cmd
  when :test
    `gzip -tq "#{path}"`
    $? == 0

  when :list
    lines = []
    `gzip -lq "#{path}"`.split("\n").each do |line|
      lines.push line[47..-1]
    end
    lines

  when :extract
    `gzip -dq "#{path}"`
    $? == 0
  end
end

def bzip2_handler(cmd, path)
  case cmd
  when :test
    `bzip2 -tq "#{path}"`
    $? == 0

  when :list
    lines = []
    `bzip2 -tv "#{path}" 2>&1`.split("\n").each do |line|
      if line =~ /\s+([^:]+?)\.bz2: .*/
        lines.push $1
      end
    end
    lines

  when :extract
    `bzip2 -dq "#{path}"`
    $? == 0
  end
end

def p7zip_handler(cmd, path)
  case cmd
  when :test
    `7za t "#{path}" > /dev/null`
    $? == 0

  when :list
    lines = []
    `7za l "#{path}"`.split("\n")[12..-3].each do |line|
      lines.push line[53..-1]
    end
    lines

  when :extract
    `7za x "#{path}" > /dev/null`
    $? == 0
  end
end

def tar_handler(cmd, path)
  case cmd
  when :test
    true

  when :list
    lines = []
    `tar tvf "#{path}"`.split("\n").each do |line|
      lines.push line[51..-1]
    end
    lines

  when :extract
    `tar xf "#{path}"`
    $? == 0
  end
end

def tar_gzip_handler(cmd, path)
  case cmd
  when :test
    `gzip -tq "#{path}"`
    $? == 0

  when :list
    lines = []
    `tar tvzf "#{path}"`.split("\n").each do |line|
      lines.push line[51..-1]
    end
    lines

  when :extract
    `tar xzf "#{path}"`
    $? == 0
  end
end

def tar_bzip2_handler(cmd, path)
  case cmd
  when :test
    `bzip2 -tq "#{path}"`
    $? == 0

  when :list
    lines = []
    `tar tvjf "#{path}"`.split("\n").each do |line|
      lines.push line[51..-1]
    end
    lines

  when :extract
    `tar xjf "#{path}"`
    $? == 0
  end
end

def tar_p7zip_handler(cmd, path)
  case cmd
  when :test
    `7za t "#{path}" > /dev/null 2>&1`
    $? == 0

  when :list
    lines = []
    `7za x "#{path}" -so 2> /dev/null | tar tvf -`.split("\n")[12..-3].each do |line|
      lines.push line[52..-1]
    end
    lines

  when :extract
    `7za x "#{path}" -so 2> /dev/null | tar xf -`
    $? == 0
  end
end

def stuffit_handler(cmd, path)
  case cmd
  when :test
    true                        # can't test this

  when :list
    return ["Cannot list StuffIt archives"]

  when :extract
    delete_originals = ""
    to_string = ""
    if not $preserve
      delete_originals = "with delete originals"
    end
    if not $extract_there
      to_string = "to POSIX file \"#{Dir.getwd}\""
    end
    `osascript <<EOF
      tell application "StuffIt Expander"
        run
        expand {POSIX file "#{path}"} #{delete_originals} #{to_string}
      end tell
EOF`
    $? == 0
  end
end

def unarchive_helper(file, base, sepchar, handler)
  if not send(handler, :test, file)
    puts "Error: Archive '#{file}' is broken"
    return false
  end

  if $command == :test
    return true
  end

  common_prefix = nil
  count = 0

  send(handler, :list, file).each do |entry|
    if $command == :list
      puts entry.gsub(sepchar, "/")
    end
    if common_prefix != false
      parts = entry.chomp.split(sepchar)
      if parts
        if common_prefix == nil
          common_prefix = parts[0]
        elsif common_prefix != parts[0]
          common_prefix = false
        end
      else
        common_prefix = false
      end
    end
    count += 1
  end

  if $command != :extract
    return true
  end

  if $extract_there
    target = File.dirname file
  else
    target = Dir.getwd
  end

  if count == 0
    puts "Error: no archive entries in '#{file}'"
    return false
  elsif count > 0 and common_prefix == false
    target = File.join(target, File.basename(base))
  end

  if File.exists? target and not File.directory? target
    puts "Error: target directory already exists: #{target}"
    return false
  end

  if not File.exist? target
    File.makedirs target
  end

  Dir.chdir(target) do
    if send(handler, :extract, file)
      if $verbose
        puts "#{File.basename(file)} -> #{target}: #{count} entries"
      end
      if not $preserve and File.exist? file
        File.delete file
      end
    else
      return false
    end
  end

  true
end

def unarchive(file)
  file = File.expand_path file.path
  base = File.basename(file)
  case file
  when /\.s[dh]k$/i
    if $command == :identify
      puts "#{base}: ShrinkIt SDK/SHK"
    else
      unarchive_helper(file, file.gsub(/\.s[dh]k$/i, ""), ":", 
                       :shrinkit_handler)
    end

  when /\.b[xnq]y$/i
    if $command == :identify
      puts "#{base}: ShrinkIt BXY/BNY/BQY"
    else
      unarchive_helper(file, file.gsub(/\.b[xnq]y$/i, ""), "/",
                       :shrinkit_handler)
    end

  when /\.zip$/i
    if $command == :identify
      puts "#{base}: Zip"
    else
      unarchive_helper(file, file.gsub(/\.zip$/i, ""), "/", 
                       :unzip_handler)
    end

  when /\.arj$/i
    if $command == :identify
      puts "#{base}: Arj"
    else
      unarchive_helper(file, file.gsub(/\.arj$/i, ""), "/", 
                       :unarj_handler)
    end

  when /\.rar$/i
    if $command == :identify
      puts "#{base}: Rar"
    else
      unarchive_helper(file, file.gsub(/\.rar$/i, ""), "/", 
                       :unrar_handler)
    end

  when /\.(lha|lzh)$/i
    if $command == :identify
      puts "#{base}: LHArc"
    else
      unarchive_helper(file, file.gsub(/\.(lha|lzh)$/i, ""), "/", 
                       :lha_handler)
    end

  when /\.tar$/
    if $command == :identify
      puts "#{base}: Tar"
    else
      unarchive_helper(file, file.gsub(/\.tar$/, ""), "/", 
                       :tar_handler)
    end

  when /\.tar\.gz$/
    if $command == :identify
      puts "#{base}: Tar Gzip"
    else
      unarchive_helper(file, file.gsub(/\.tar\.gz$/, ""), "/", 
                       :tar_gzip_handler)
    end

  when /\.tgz$/
    if $command == :identify
      puts "#{base}: Tar Gzip"
    else
      unarchive_helper(file, file.gsub(/\.tgz$/, ""), "/", 
                       :tar_gzip_handler)
    end

  when /\.tar\.Z$/
    if $command == :identify
      puts "#{base}: Tar Compress"
    else
      unarchive_helper(file, file.gsub(/\.tar\.Z$/, ""), "/", 
                       :tar_gzip_handler)
    end

  when /\.taz$/
    if $command == :identify
      puts "#{base}: Tar Compress"
    else
      unarchive_helper(file, file.gsub(/\.taz$/, ""), "/", 
                       :tar_gzip_handler)
    end

  when /\.tar\.bz2$/
    if $command == :identify
      puts "#{base}: Tar Bzip2"
    else
      unarchive_helper(file, file.gsub(/\.tar\.bz2$/, ""), "/",
                       :tar_bzip2_handler)
    end

  when /\.tbz$/
    if $command == :identify
      puts "#{base}: Tar Bzip2"
    else
      unarchive_helper(file, file.gsub(/\.tbz$/, ""), "/",
                       :tar_bzip2_handler)
    end

  when /\.tar\.7z$/
    if $command == :identify
      puts "#{base}: Tar 7zip"
    else
      unarchive_helper(file, file.gsub(/\.tar\.7z$/, ""), "/",
                       :tar_p7zip_handler)
    end

  when /\.gz$/
    if $command == :identify
      puts "#{base}: Gzip"
    else
      unarchive_helper(file, file.gsub(/\.gz$/, ""), "/",
                       :gzip_handler)
    end

  when /\.Z$/
    if $command == :identify
      puts "#{base}: Compress"
    else
      unarchive_helper(file, file.gsub(/\.Z$/, ""), "/",
                       :gzip_handler)
    end

  when /\.bz2$/
    if $command == :identify
      puts "#{base}: Bzip2"
    else
      unarchive_helper(file, file.gsub(/\.bz2$/, ""), "/", 
                       :bzip2_handler)
    end

  when /\.7z$/
    if $command == :identify
      puts "#{base}: 7zip"
    else
      unarchive_helper(file, file.gsub(/\.7z$/, ""), "/", 
                       :p7zip_handler)
    end

  when /\.(bin|sea|hqx|sit)$/i
    if $command == :identify
      puts "#{base}: StuffIt"
    else
      unarchive_helper(file, file.gsub(/\.(bin|sea|hqx|sit)$/i, ""), "/", 
                       :stuffit_handler)
    end

  else
    if $command == :identify
      puts "#{base}: <unknown>"
    end
  end
end

opts.each do |opt, arg|
  case opt
  when "--there"
    $extract_there = true
  when "--delete"
    $preserve = false
  when "--verbose"
    $verbose = true
  when "--identify"
    $command = :identify
  when "--test"
    $command = :test
  when "--list"
    $command = :list
  when "--help"
    RDoc::usage
    puts "formats (capitalized extensions are case-insensitive):"
    $handlers.each do |handler|
      handler.advertise
    end
  end
end 

ARGV.each do |file|
  if File.file? file
    handled = false
    $handlers.each do |handler|
      if handler.match? file
        send(handler, $command, file)
        handled = true
      end
    end
    if not handled
      unarchive File.new(file)
    end
  end
end
